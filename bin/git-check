#!/bin/bash

# Some variables to start off
VW=$(tput cols)
PDIR=$1

function echoBranch {
  # This function takes a string to print, and an optional branch name to print.
  # If we get a branch name, it will be right aligned
  # The string to print first can be an empty string, but must exist.

  if [ -z ${2+x} ]; then
    # No branch to echo, just echo the first argument
    ARGS+="%s\n"
    TEMP+=("$1")
  else
    # Work out how wide we want for right aligning the branch name
    WIDTH=$((VW-${#1}))

    # This is the really weird way we have to right align things
    ARGS+="%s%"$WIDTH"s\n"
    TEMP+=("$1" "$2")  
  fi
}


function echoBranchMaybe {
  # This is for keeping track of what branches we have already echoed
  # It is seperate from echoBranch, because the first time we do it, we 
  # want to echo a branch that is not in the list (the current branch)

  if [ $i -lt $length ]; then
    # We have a branch that we haven't echoed yet, let's do that
    echoBranch "$1" "${BRANCHES[$i]}"
    i=$(($i+1))
  else
    # No branches left, so we'll just echo the first argument
    echoBranch "$1"
  fi
}


if [ ! -d "$PDIR" ]; then
  printf "%s\n" "No directory, or non-existanct directory specified. Using ~/dev/. Press any key to continue."
  PDIR=$HOME"/dev/"
  read
fi

printf "Gathering information."

# Loop. Forever.
while [ 1 -ne 0 ]; do
  # Update width (incase we have changed it)
  VW=$(tput cols)

  # To do things nicely, we have a string of arguments for printf
  # and an array of strings that it will deal with
  ARGS=""
  TEMP=()
 
  # Loop through directories in the parent directory
  for d in $PDIR/*/; do
    cd $d
    # Only do stuff if we have a .git directory, otherwise bad things
    if [ -d "./.git" ]; then

      # Let's update the remotes, otherwise half this script is pointless
      git fetch &> /dev/null

      # Split up the directory path, and get the final one (directory name)
      IFS='/' read -a array <<< "$d"
      DIR="${array[-1]}"

      # Make the repo name and checked out branch bold
      ARGS+="\e[1m"
      echoBranch $DIR "$(git branch | grep '*')"
      ARGS+="\e[0m" # And revert boldness

      # Let's get the other branch names (because I like my local branches to be clean)
      BRANCHES=()
      eval "$(git for-each-ref --shell --format='if [[ "%(HEAD)" != *"*"* ]]; then BRANCHES+=(%(refname:short)); fi' refs/heads/)"
      length=${#BRANCHES[@]}
      i=0

      git diff --exit-code &> /dev/null
      if [ $? -ne 0 ]; then
        echoBranchMaybe "Unstaged changes"
      fi

      git diff --cached --exit-code &> /dev/null
      if [ $? -ne 0 ]; then
        echoBranchMaybe "Staged, uncommited changes"
      fi

      git ls-files --other --exclude-standard --directory | head -1 &> /dev/null
      if [ $? -ne 0 ]; then
        echoBranchMaybe "Untracked, unignored files"
      fi

      # Now we are going to get a bunch of hashes for commits at different points

      # The latest commit on this branch
      LOCAL=$((git rev-parse @) 2>&1)
      # Where we branches off master
      MASTERPOINT=$((git merge-base @ origin/master) 2>&1)
      # Where master is currently
      MASTER=$((git rev-parse origin/master) 2>&1)
      # The remote for this branch
      REMOTE=$((git rev-parse @{u}) 2>&1)
      # The last commit that is both on local and remote
      BASE=$((git merge-base @ @{u}) 2>&1)

      if [ $? -ne 0 ]; then
        # This just means there was an error with the last one.
        # AFAIK, this is only when there is no tracking branch
        echoBranchMaybe "No tracking branch"

      elif [ $LOCAL = $REMOTE ]; then
        # The local and master branches are at the same point
        echoBranchMaybe "Up to date"

      elif [ $LOCAL = $BASE ]; then
        # Local branch isn't up to date with remote, but is still on the same line
        echoBranchMaybe "Behind"

      elif [ $REMOTE = $BASE ]; then
        # Remote isn't up to date with local, but is still on the same line
        echoBranchMaybe "Ahead"

      else
        # We have diverged somewhere
        echoBranchMaybe "Diverged"
      fi
  
      if [ $MASTERPOINT != $MASTER ]; then
        # Master is further ahead than where we branched off, rebasing is necessary.
        echoBranchMaybe "Needs rebased"
      fi

      while [ $i -lt $length ]; do
        # Incase we haven't already listed all the branches, 
        # let's go through the rest and show them (how many do you have?)
        echoBranchMaybe ""
      done

      ARGS+="\n"
    fi
  done

clear
printf "$ARGS" "${TEMP[@]}"

# This allows us to refresh the information without having to wait for the timeout.
read -t 30
printf "Updating..."

done
