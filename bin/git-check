#!/bin/bash

# Some variables to start off
VW=$(tput cols)
PDIR=$1

function echoBranch {
  if [ -z ${2+x} ]; then
    ARGS+="%s\n"
    TEMP+=("$1")
  else
    # Work out how wide we want for right aligning the branch name
    WIDTH=$((VW-${#1}))

    # This is the really weird way we have to right align things
    ARGS+="%s%"$WIDTH"s\n"
    TEMP+=("$1" "$2")  
  fi
}


function echoBranchMaybe {
  if [ $i -lt $length ]; then
    echoBranch "$1" "${BRANCHES[$i]}"
    i=$(($i+1))
  else
    echoBranch "$1"
  fi
}


if [ ! -d "$PDIR" ]; then
  printf "%s\n" "No directory, or non-existanct directory specified. Using ~/dev/. Press any key to continue."
  PDIR=$HOME"/dev/"
  read
fi

printf "Gathering information."

# Loop. Forever.
while [ 1 -ne 0 ]; do

  # To do things nicely, we have a string of arguments for printf
  # and an array of strings that it will deal with
  ARGS=""
  TEMP=()
 
  # Loop through directories in the parent directory
  for d in $PDIR/*/; do
    cd $d
    # Only do stuff if we have a .git directory, otherwise bad things
    if [ -d "./.git" ]; then

      # Let's update the remotes, otherwise half this script is pointless
      git fetch >> /dev/null

      # Split up the directory path, and get the final one (directory name)
      IFS='/' read -a array <<< "$d"
      DIR="${array[-1]}"

      # Make the repo name and checked out branch bold
      ARGS+="\e[1m"
      echoBranch $DIR "$(git branch | grep '*')"
      ARGS+="\e[0m" # And revert boldness

      # Let's get the other branch names (because I like my local branches to be clean)
      BRANCHES=()
      eval "$(git for-each-ref --shell --format='if [[ "%(HEAD)" != *"*"* ]]; then BRANCHES+=(%(refname:short)); fi' refs/heads/)"
      length=${#BRANCHES[@]}
      i=0

      git diff --exit-code >> /dev/null
      if [ $? -ne 0 ]; then
        ARGS+="%s"
        TEMP+=("Unstaged changes")
      fi

      git diff --cached --exit-code >> /dev/null
      if [ $? -ne 0 ]; then
        ARGS+="%s\n"
        TEMP+=("Staged, uncommited changes")
      fi

      git ls-files --other --exclude-standard --directory | head -1
      if [ $? -ne 0 ]; then
        ARGS+="%s\n"
        TEMP+=("Untracked, unignored files")
      fi

      LOCAL=$((git rev-parse @) 2>&1)
      MASTERPOINT=$((git merge-base @ origin/master) 2>&1)
      MASTER=$((git rev-parse origin/master) 2>&1)
      REMOTE=$((git rev-parse @{u}) 2>&1)
      BASE=$((git merge-base @ @{u}) 2>&1)

      if [ $? -ne 0 ]; then
        echoBranchMaybe "No tracking branch"
      elif [ $LOCAL = $REMOTE ]; then
        echoBranchMaybe "Up to date"
      elif [ $LOCAL = $BASE ]; then
        echoBranchMaybe "Behind"
      elif [ $REMOTE = $BASE ]; then
        echoBranchMaybe "Ahead"
      else
        echoBranchMaybe "Diverged"
      fi
  
      if [ $MASTERPOINT != $MASTER ]; then
        echoBranchMaybe "Needs rebased"
      fi

      while [ $i -lt $length ]; do
        echoBranchMaybe ""
      done

      ARGS+="\n"
    fi
  done

clear
printf "$ARGS" "${TEMP[@]}"
read -t 30
printf "Updating..."
done
